// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Corbanistan

//@version=6
indicator('Range Indicator: Golden Pocket, Liquidity, & FVG', overlay = true, max_lines_count = 500, max_boxes_count = 500)

// ══════════════════════════════════════════════════════════════════════════════
// 1. INPUT SETTINGS
// ══════════════════════════════════════════════════════════════════════════════

// --- Visual Settings ---
string GRP_VIS = 'Visuals'
color i_boxColor       = input.color(color.new(#787b86, 92), 'Range Background', group = GRP_VIS)
color i_gpBullishColor = input.color(color.new(#4caf50, 60), 'Bullish GP Color', group = GRP_VIS)
color i_gpBearishColor = input.color(color.new(#f44336, 60), 'Bearish GP Color', group = GRP_VIS)
color i_liqColor       = input.color(color.new(#ffeb3b, 85), 'Liquidity Zones Color', group = GRP_VIS)
color i_lineColor      = input.color(color.white, 'Boundary Line Color', group = GRP_VIS)
bool  i_showLines      = input.bool(true, 'Show Price Lines', group = GRP_VIS)
bool  i_showLabels     = input.bool(true, 'Show Price Labels', group = GRP_VIS)

// --- Range Settings ---
string GRP_RANGE = 'Range Settings'
string MODE_ROLLING = 'Rolling Lookback'
string MODE_PREV_DAY = 'Previous Day'
string MODE_PREV_WEEK = 'Previous Week'
string i_rangeMode     = input.string(MODE_ROLLING, 'Range Mode', options = [MODE_ROLLING, MODE_PREV_DAY, MODE_PREV_WEEK], group = GRP_RANGE)
bool   i_autoFit       = input.bool(true, 'Auto-Fit Box to Last High/Low (Rolling Only)', group = GRP_RANGE)
int    i_lookback      = input.int(100, 'Lookback Period (Rolling Only)', minval = 2, group = GRP_RANGE)
int    i_offsetR       = input.int(50, 'Box Offset Right', minval = 0, group = GRP_RANGE)

// --- FVG Settings ---
string GRP_FVG = 'FVG Settings'
bool   i_showFVG       = input.bool(true, 'Show Fair Value Gaps (FVG)', group = GRP_FVG)
int    i_fvgLen        = input.int(10, 'FVG Extension (Bars)', minval = 1, group = GRP_FVG)
color  i_bullFVGColor  = input.color(color.new(#4caf50, 50), 'Bullish FVG Color', group = GRP_FVG)
color  i_bearFVGColor  = input.color(color.new(#f44336, 50), 'Bearish FVG Color', group = GRP_FVG)

// --- Moving Average Settings ---
string GRP_MA = 'Moving Average'
bool   i_showMA        = input.bool(false, 'Show Moving Average', group = GRP_MA)
string MA_SMA  = 'SMA'
string MA_EMA  = 'EMA'
string MA_WMA  = 'WMA'
string MA_VWMA = 'VWMA'
string MA_RMA  = 'RMA'
string MA_HMA  = 'HMA'
string MA_SMMA = 'SMMA'
string MA_DEMA = 'DEMA'
string MA_TEMA = 'TEMA'
string i_maType        = input.string(MA_SMA, 'MA Type', options = [MA_SMA, MA_EMA, MA_WMA, MA_VWMA, MA_RMA, MA_HMA, MA_SMMA, MA_DEMA, MA_TEMA], group = GRP_MA)
int    i_maLen         = input.int(20, 'MA Length', minval = 1, group = GRP_MA)
string i_maSrc         = input.string('close', 'MA Source', options = ['open', 'high', 'low', 'close', 'hl2', 'hlc3', 'ohlc4', 'hlcc4'], group = GRP_MA)
bool   i_maSmooth      = input.bool(false, 'Apply Smoothing', group = GRP_MA)
int    i_maSmoothLen   = input.int(3, 'Smoothing Length', minval = 1, group = GRP_MA)
string i_maSmoothType  = input.string(MA_SMA, 'Smoothing Type', options = [MA_SMA, MA_EMA, MA_WMA, MA_RMA], group = GRP_MA)
color  i_maColor       = input.color(color.new(#2196f3, 0), 'MA Color', group = GRP_MA)
int    i_maWidth       = input.int(2, 'MA Line Width', minval = 1, maxval = 5, group = GRP_MA)

// ══════════════════════════════════════════════════════════════════════════════
// 3. CORE RANGE CALCULATIONS
// ══════════════════════════════════════════════════════════════════════════════

// Calculate range high/low based on selected mode
// Fix: Use [1] offset to exclude current bar from range calculation (enables proper SFP detection)
var float rHigh = na
var float rLow = na
var int anchorBar = na

if i_rangeMode == MODE_ROLLING
    // Rolling lookback mode - exclude current bar for proper SFP signals
    // Note: highestbars/lowestbars return negative offsets, use math.abs for indexing
    int hOff = ta.highestbars(high[1], i_lookback)
    int lOff = ta.lowestbars(low[1], i_lookback)
    rHigh := high[1 + math.abs(hOff)]
    rLow := low[1 + math.abs(lOff)]
    anchorBar := i_autoFit ? bar_index - math.max(math.abs(hOff), math.abs(lOff)) - 1 : bar_index - i_lookback
else if i_rangeMode == MODE_PREV_DAY
    // Previous day high/low - stable non-repainting levels
    rHigh := request.security(syminfo.tickerid, 'D', high[1], lookahead = barmerge.lookahead_on)
    rLow := request.security(syminfo.tickerid, 'D', low[1], lookahead = barmerge.lookahead_on)
    anchorBar := bar_index - i_lookback  // Approximate anchor
else if i_rangeMode == MODE_PREV_WEEK
    // Previous week high/low - stable non-repainting levels
    rHigh := request.security(syminfo.tickerid, 'W', high[1], lookahead = barmerge.lookahead_on)
    rLow := request.security(syminfo.tickerid, 'W', low[1], lookahead = barmerge.lookahead_on)
    anchorBar := bar_index - i_lookback  // Approximate anchor

float rDiff = rHigh - rLow

// Golden Pocket Fibonacci levels
float bUp = rLow + rDiff * 0.382   // Bullish GP upper
float bLo = rLow + rDiff * 0.35    // Bullish GP lower
float sUp = rHigh - rDiff * 0.35   // Bearish GP upper
float sLo = rHigh - rDiff * 0.382  // Bearish GP lower

// ══════════════════════════════════════════════════════════════════════════════
// 4. FVG LOGIC (Simple Static Boxes)
// ══════════════════════════════════════════════════════════════════════════════

if i_showFVG
    // Bullish FVG: gap up (current low > 2 bars ago high)
    if low > high[2]
        box.new(bar_index[1], low, bar_index + i_fvgLen, high[2], bgcolor = i_bullFVGColor, border_color = na)
    // Bearish FVG: gap down (current high < 2 bars ago low)
    if high < low[2]
        box.new(bar_index[1], high, bar_index + i_fvgLen, low[2], bgcolor = i_bearFVGColor, border_color = na)


// ══════════════════════════════════════════════════════════════════════════════
// 5. MOVING AVERAGE CALCULATIONS
// ══════════════════════════════════════════════════════════════════════════════

// Get the price source for MA calculation
float maSrc = switch i_maSrc
    'open'  => open
    'high'  => high
    'low'   => low
    'close' => close
    'hl2'   => hl2
    'hlc3'  => hlc3
    'ohlc4' => ohlc4
    'hlcc4' => hlcc4
    => close

// Pre-calculate ALL MA types on every bar to ensure consistent TA function calls
// (Pine Script requires TA functions to be called on each bar for accurate historical state)
float ma_sma  = ta.sma(maSrc, i_maLen)
float ma_ema  = ta.ema(maSrc, i_maLen)
float ma_wma  = ta.wma(maSrc, i_maLen)
float ma_vwma = ta.vwma(maSrc, i_maLen)
float ma_rma  = ta.rma(maSrc, i_maLen)
float ma_hma  = ta.hma(maSrc, i_maLen)
// DEMA = 2 * EMA - EMA(EMA)
float dema_ema1 = ta.ema(maSrc, i_maLen)
float dema_ema2 = ta.ema(dema_ema1, i_maLen)
float ma_dema   = 2 * dema_ema1 - dema_ema2
// TEMA = 3 * EMA - 3 * EMA(EMA) + EMA(EMA(EMA))
float tema_ema1 = ta.ema(maSrc, i_maLen)
float tema_ema2 = ta.ema(tema_ema1, i_maLen)
float tema_ema3 = ta.ema(tema_ema2, i_maLen)
float ma_tema   = 3 * tema_ema1 - 3 * tema_ema2 + tema_ema3

// Select the appropriate pre-calculated MA based on user choice
float maValue = switch i_maType
    MA_SMA  => ma_sma
    MA_EMA  => ma_ema
    MA_WMA  => ma_wma
    MA_VWMA => ma_vwma
    MA_RMA  => ma_rma
    MA_HMA  => ma_hma
    MA_SMMA => ma_rma  // SMMA is equivalent to RMA
    MA_DEMA => ma_dema
    MA_TEMA => ma_tema
    => ma_sma

// Pre-calculate smoothing MAs (all types, called every bar)
float smooth_sma = ta.sma(maValue, i_maSmoothLen)
float smooth_ema = ta.ema(maValue, i_maSmoothLen)
float smooth_wma = ta.wma(maValue, i_maSmoothLen)
float smooth_rma = ta.rma(maValue, i_maSmoothLen)

// Select smoothed value if smoothing is enabled
float maSmoothed = switch i_maSmoothType
    MA_SMA => smooth_sma
    MA_EMA => smooth_ema
    MA_WMA => smooth_wma
    MA_RMA => smooth_rma
    => smooth_sma

float maFinal = i_maSmooth ? maSmoothed : maValue

// Plot the moving average (conditional on toggle)
plot(i_showMA ? maFinal : na, 'Moving Average', color = i_maColor, linewidth = i_maWidth)

// ══════════════════════════════════════════════════════════════════════════════
// 6. VISUAL ELEMENTS (Boxes, Lines, Labels)
// ══════════════════════════════════════════════════════════════════════════════

var box b_Range   = box.new(na, na, na, na, xloc = xloc.bar_index, bgcolor = i_boxColor, border_color = color.gray)
var box b_Bullish = box.new(na, na, na, na, xloc = xloc.bar_index, bgcolor = i_gpBullishColor, border_color = na, text = 'BULLISH Golden Pocket ↑', text_color = color.white, text_size = size.small)
var box b_Bearish = box.new(na, na, na, na, xloc = xloc.bar_index, bgcolor = i_gpBearishColor, border_color = na, text = 'BEARISH Golden Pocket ↓', text_color = color.white, text_size = size.small)
var box b_LiqTop  = box.new(na, na, na, na, xloc = xloc.bar_index, bgcolor = i_liqColor, border_color = na, text = 'LIQUIDITY', text_color = color.white, text_size = size.tiny)
var box b_LiqBot  = box.new(na, na, na, na, xloc = xloc.bar_index, bgcolor = i_liqColor, border_color = na, text = 'LIQUIDITY', text_color = color.white, text_size = size.tiny)

var array<line>  l_levels  = array.new<line>()
var array<label> lb_prices = array.new<label>()

if barstate.isfirst
    for i = 0 to 7
        array.push(l_levels, line.new(na, na, na, na, xloc = xloc.bar_index, color = i_lineColor))
        array.push(lb_prices, label.new(na, na, '', xloc = xloc.bar_index, color = color.new(color.black, 100), textcolor = i_lineColor, size = size.small, style = label.style_label_left))

if barstate.islast
    int rightBar = bar_index + i_offsetR
    
    // Update main boxes
    box.set_lefttop(b_Range, anchorBar, rHigh)
    box.set_rightbottom(b_Range, rightBar, rLow)
    box.set_lefttop(b_Bullish, anchorBar, bUp)
    box.set_rightbottom(b_Bullish, rightBar, bLo)
    box.set_lefttop(b_Bearish, anchorBar, sUp)
    box.set_rightbottom(b_Bearish, rightBar, sLo)
    box.set_lefttop(b_LiqTop, anchorBar, rHigh)
    box.set_rightbottom(b_LiqTop, rightBar, rHigh - rDiff * 0.05)
    box.set_lefttop(b_LiqBot, anchorBar, rLow + rDiff * 0.05)
    box.set_rightbottom(b_LiqBot, rightBar, rLow)
    
    // Update price lines and labels
    array<float> p_vals = array.from(rHigh, rHigh - rDiff * 0.05, sUp, sLo, bUp, bLo, rLow + rDiff * 0.05, rLow)
    for i = 0 to 7
        float v = array.get(p_vals, i)
        // Update lines if enabled
        if i_showLines
            line.set_xy1(array.get(l_levels, i), anchorBar, v)
            line.set_xy2(array.get(l_levels, i), rightBar, v)
        else
            line.set_xy1(array.get(l_levels, i), na, na)
            line.set_xy2(array.get(l_levels, i), na, na)
        // Update labels if enabled
        if i_showLabels
            label.set_xy(array.get(lb_prices, i), rightBar, v)
            label.set_text(array.get(lb_prices, i), ' ' + str.tostring(v, format.mintick))
        else
            label.set_xy(array.get(lb_prices, i), na, na)

// ══════════════════════════════════════════════════════════════════════════════
// 7. SIGNAL LOGIC
// ══════════════════════════════════════════════════════════════════════════════

// Swing Failure Pattern (SFP) - now works correctly with [1] offset fix
bool sfpShort = high > rHigh and close < rHigh
bool sfpLong  = low < rLow and close > rLow

// Golden Pocket touch tracking
var bool tBear = false
var bool tBull = false

if high >= sLo and low <= sUp
    tBear := true

if low <= bUp and high >= bLo
    tBull := true

// 2-Candle reversal pattern
bool pL = close[2] < open[2] and close[1] > open[1] and close > high[1]  // Bullish reversal
bool pS = close[2] > open[2] and close[1] < open[1] and close < low[1]   // Bearish reversal

// Combined signals
bool signalLongOnly  = tBull and pL
bool signalShortOnly = tBear and pS

// Reset touch flags after signal or breakout
if signalShortOnly or (tBear and high > rHigh)
    tBear := false

if signalLongOnly or (tBull and low < rLow)
    tBull := false

// ══════════════════════════════════════════════════════════════════════════════
// 8. ALERTS (Enhanced with Price Levels)
// ══════════════════════════════════════════════════════════════════════════════

// Pre-calculate crossover/crossunder to ensure consistent execution on every bar
bool gpTouchBearish = ta.crossover(high, sLo)
bool gpTouchBullish = ta.crossunder(low, bUp)

alertcondition(gpTouchBearish or gpTouchBullish, '1. GP Touch', 'Price entered Golden Pocket zone.')
alertcondition(signalLongOnly, '2. Long: 2-Candle Pattern', 'Long signal confirmed in BULLISH Golden Pocket.')
alertcondition(signalShortOnly, '3. Short: 2-Candle Pattern', 'Short signal confirmed in BEARISH Golden Pocket.')
alertcondition(sfpLong, '4. SFP Long (Liquidity Grab)', 'SFP detected: Liquidity grab below range low.')
alertcondition(sfpShort, '5. SFP Short (Liquidity Grab)', 'SFP detected: Liquidity grab above range high.')